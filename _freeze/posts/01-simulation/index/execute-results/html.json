{
  "hash": "cb6b8882c8469b15a0877768dee2a9ab",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Mini Project 1\"\nauthor: \"Abby Sikora\"\ndate: \"2025-04-28\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.1\n✔ purrr     1.0.4     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n\n\n“I have followed all rules for collaboration for this project, and I have not used generative AI on this project.”\n\n#Simulation for Y(min)~Normal(mu = 10, SD = 2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5       # sample size\nmu <- 10     # population mean\nsigma <- 2   # population standard deviation\n\n# generate a random sample of n observations from a normal population\nsingle_sample <- rnorm(n, mu, sigma) |> round(2)\n# look at the sample\nsingle_sample \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  9.67 13.74  8.57  9.32 12.34\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute the sample mean\nsample_min <- min(single_sample)\n# look at the sample mean\nsample_min   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.57\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df <- tibble(xvals = seq(mu - 4 * sigma, mu + 4 * sigma, length.out = 500)) |>\n  mutate(xvals_density = dnorm(xvals, mu, sigma))\n\n## plot the population model density curve\nggplot(data = plot_df, aes(x = xvals, y = xvals_density)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample), aes(x = single_sample, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample mean\n  geom_vline(xintercept = sample_min, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Normal with Mu = 10 and sigma = 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\n\n#Simulation for Y(max)~Normal(mu = 10, SD = 2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample_max <- max(single_sample)\n# look at the sample mean\nsample_max   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13.74\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df <- tibble(xvals = seq(mu - 4 * sigma, mu + 4 * sigma, length.out = 500)) |>\n  mutate(xvals_density = dnorm(xvals, mu, sigma))\n\n## plot the population model density curve\nggplot(data = plot_df, aes(x = xvals, y = xvals_density)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample), aes(x = single_sample, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample mean\n  geom_vline(xintercept = sample_max, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Normal with Mu = 10 and sigma = 2\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n#Generating E(Ymin) & E(Ymax) for Normal Dist\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_samp_min <- function(mu, sigma, n) {\n  \n  single_sample <- rnorm(n, mu, sigma)\n  sample_min <- min(single_sample)\n  \n  return(sample_min)\n}\n\n## test function once:\ngenerate_samp_min(mu = mu, sigma = sigma, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.0309\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000      # number of simulations\n\n## code to map through the function. \n## the \\(i) syntax says to just repeat the generate_samp_mean function\n## nsim times\nmins <- map_dbl(1:nsim, \\(i) generate_samp_min(mu = mu, sigma = sigma, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmins_df <- tibble(mins)\nmins_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    mins\n   <dbl>\n 1  6.85\n 2  9.24\n 3  6.74\n 4  5.31\n 5  9.58\n 6  7.65\n 7 10.2 \n 8  7.03\n 9  6.40\n10  7.93\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmins_df |>\n  summarise(mean_samp_dist = mean(mins),\n            var_samp_dist = var(mins),\n            sd_samp_dist = sd(mins))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1           7.67          1.79         1.34\n```\n\n\n:::\n\n```{.r .cell-code}\n ## E(Ymax)\n\ngenerate_samp_max <- function(mu, sigma, n) {\n  \n  single_sample <- rnorm(n, mu, sigma)\n  sample_max <- max(single_sample)\n  \n  return(sample_max)\n}\n## test function once:\ngenerate_samp_max(mu = mu, sigma = sigma, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 13.62979\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000      # number of simulations\n\n## code to map through the function. \n## the \\(i) syntax says to just repeat the generate_samp_mean function\n## nsim times\nmaxs <- map_dbl(1:nsim, \\(i) generate_samp_max(mu = mu, sigma = sigma, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmaxs_df <- tibble(maxs)\nmaxs_df\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n    maxs\n   <dbl>\n 1 10.7 \n 2 13.9 \n 3 11.5 \n 4  8.46\n 5 12.5 \n 6 12.1 \n 7 11.3 \n 8  9.93\n 9 11.5 \n10 11.8 \n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmaxs_df |>\n  summarise(mean_samp_dist = mean(maxs),\n            var_samp_dist = var(maxs),\n            sd_samp_dist = sd(maxs))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1           12.3          1.85         1.36\n```\n\n\n:::\n:::\n\n\n\n#Normal Dist. Histograms\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mins_df, aes(x = mins)) +\n  geom_histogram(colour = \"darkolivegreen4\", fill = \"darkolivegreen1\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Mins\",\n       title = paste(\"Sampling Distribution of the \\nSample Mins when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df, aes(x = maxs)) +\n  geom_histogram(colour = \"purple\", fill = \"pink\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Maxs\",\n       title = paste(\"Sampling Distribution of the \\nSample Maxs when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n\n\n\n\n#Simulation for Y(min)~Unif(7, 13)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5       # sample size\ntheta1 <- 7     # non-negative parameter 1\ntheta2 <- 13   # non-negative parameter 2\n\n# generate a random sample of n observations from a Uniform population\nsingle_sample1 <- runif(n, theta1, theta2) |> round(2)\n# look at the sample\nsingle_sample1 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10.19 10.26  9.73  8.45 12.33\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute the sample min\nsample_min1 <- min(single_sample1)\n# look at the sample min\nsample_min1   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.45\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df1 <- tibble(xvals1 = seq(theta1, theta2, length.out = 500)) |>\n  mutate(xvals_density1 = dunif(xvals1, theta1, theta2))\n\n## plot the population model density curve\nggplot(data = plot_df1, aes(x = xvals1, y = xvals_density1)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample1), aes(x = single_sample1, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample min\n  geom_vline(xintercept = sample_min1, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Uniform with theta1 = 7 and theta2 = 13\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n\n#Simulation for Y(max)~Unif(7, 13)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute the sample max\nsample_max1 <- max(single_sample1)\n# look at the sample max\nsample_max1   \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.33\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df1 <- tibble(xvals1 = seq(theta1, theta2, length.out = 500)) |>\n  mutate(xvals_density1 = dunif(xvals1, theta1, theta2))\n\n## plot the population model density curve\nggplot(data = plot_df1, aes(x = xvals1, y = xvals_density1)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample1), aes(x = single_sample1, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample max\n  geom_vline(xintercept = sample_max1, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Uniform with theta1 = 7 and theta2 = 13\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n#Generating E(Ymin) & E(Ymax) for Uniform Distribution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_samp_min1 <- function(theta1, theta2, n) {\n  \n  single_sample1 <- runif(n, theta1, theta2)\n  sample_min1 <- min(single_sample1)\n  \n  return(sample_min1)\n}\n\n## test function once:\ngenerate_samp_min1(theta1 = theta1, theta2 = theta2, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7.665332\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000      # number of simulations\n\n## code to map through the function. \n## the \\(i) syntax says to just repeat the generate_samp_mean function\n## nsim times\nmins1 <- map_dbl(1:nsim, \\(i) generate_samp_min1(theta1 = theta1, theta2 = theta2, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmins_df1 <- tibble(mins1)\nmins_df1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n   mins1\n   <dbl>\n 1  8.01\n 2  7.87\n 3  7.80\n 4  7.22\n 5  9.20\n 6  8.10\n 7  9.02\n 8  7.89\n 9  7.15\n10  7.79\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmins_df1 |>\n  summarise(mean_samp_dist = mean(mins1),\n            var_samp_dist = var(mins1),\n            sd_samp_dist = sd(mins1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1           7.98         0.702        0.838\n```\n\n\n:::\n\n```{.r .cell-code}\n ## E(Ymax)\n\ngenerate_samp_max1 <- function(theta1, theta2, n) {\n  \n  single_sample1 <- runif(n, theta1, theta2)\n  sample_max1 <- max(single_sample1)\n  \n  return(sample_max1)\n}\n\n## test function once:\ngenerate_samp_max1(theta1 = theta1, theta2 = theta2, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12.56424\n```\n\n\n:::\n\n```{.r .cell-code}\nnsim <- 5000      # number of simulations\n\n## code to map through the function. \n## the \\(i) syntax says to just repeat the generate_samp_mean function\n## nsim times\nmaxs1 <- map_dbl(1:nsim, \\(i) generate_samp_max1(theta1 = theta1, theta2 = theta2, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmaxs_df1 <- tibble(maxs1)\nmaxs_df1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n   maxs1\n   <dbl>\n 1  9.38\n 2 12.8 \n 3 12.9 \n 4 11.5 \n 5 11.8 \n 6 12.1 \n 7 12.7 \n 8 11.3 \n 9 10.3 \n10 12.3 \n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmaxs_df1 |>\n  summarise(mean_samp_dist = mean(maxs1),\n            var_samp_dist = var(maxs1),\n            sd_samp_dist = sd(maxs1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1           12.0         0.730        0.855\n```\n\n\n:::\n:::\n\n\n\n#Uniform Dist. Histograms\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mins_df1, aes(x = mins1)) +\n  geom_histogram(colour = \"darkolivegreen4\", fill = \"darkolivegreen1\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Mins\",\n       title = paste(\"Sampling Distribution of the \\nSample Mins when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df1, aes(x = maxs1)) +\n  geom_histogram(colour = \"purple\", fill = \"pink\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Maxs\",\n       title = paste(\"Sampling Distribution of the \\nSample Maxs when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n:::\n\n\n\n#Simulation for Y(min)~Exp(lambda = 0.5)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5       # sample size\nlambda <- 0.5\nmu <- 1 / lambda   # population mean\nsigma <- sqrt(1 / lambda ^ 2)  # population standard deviation\n\n# generate a random sample of n observations from a normal population\nsingle_sample2 <- rexp(n, lambda) |> round(2)\n# look at the sample\nsingle_sample2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.47 6.05 0.98 0.36 1.04\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute the sample min\nsample_min2 <- min(single_sample2)\n# look at the sample min\nsample_min2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.36\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df2 <- tibble(xvals2 = seq(0, mu + 4 * sigma, length.out = 500)) |>\n  mutate(xvals_density = dexp(xvals2, lambda))\n\n## plot the population model density curve\nggplot(data = plot_df2, aes(x = xvals2, y = xvals_density)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample2), aes(x = single_sample2, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample min\n  geom_vline(xintercept = sample_min2, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Exponential with Lambda = 0.5\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\n\n#Simulation for Y(max)~Exp(lambda = 0.5)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute the sample max\nsample_max2 <- max(single_sample2)\n# look at the sample max\nsample_max2 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6.05\n```\n\n\n:::\n\n```{.r .cell-code}\n# generate a range of values that span the population\nplot_df2 <- tibble(xvals2 = seq(0, mu + 4 * sigma, length.out = 500)) |>\n  mutate(xvals_density = dexp(xvals2, lambda))\n\n## plot the population model density curve\nggplot(data = plot_df2, aes(x = xvals2, y = xvals_density)) +\n  geom_line() +\n  theme_minimal() +\n  ## add the sample points from your sample\n  geom_jitter(data = tibble(single_sample2), aes(x = single_sample2, y = 0),\n              width = 0, height = 0.005) +\n  ## add a line for the sample max\n  geom_vline(xintercept = sample_max2, colour = \"red\") +\n  labs(x = \"y\", y = \"density\",\n       title = \"Exponential with Lambda = 0.5\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n#Generating E(Ymin) & E(Ymax) for Exponential Distribution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_exp_min2 <- function(lambda, n) {\n  \n  single_sample2 <- rexp(n, lambda)\n  sample_min2 <- min(single_sample2)\n  \n  return(sample_min2)\n}\n\n## test function once:\ngenerate_exp_min2(lambda = lambda, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1351427\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3.915946\n\nnsim <- 5000      # number of simulations\n\nmins2 <- map_dbl(1:nsim, \\(i) generate_exp_min2(lambda = lambda, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmins_df2 <- tibble(mins2)\nmins_df2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n     mins2\n     <dbl>\n 1 0.597  \n 2 0.00459\n 3 0.717  \n 4 0.551  \n 5 0.0879 \n 6 0.271  \n 7 0.0106 \n 8 0.412  \n 9 0.00550\n10 0.756  \n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmins_df2 |>\n  summarise(min_samp_dist = mean(mins2),\n            var_samp_dist = var(mins2),\n            sd_samp_dist = sd(mins2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  min_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1         0.404         0.166        0.408\n```\n\n\n:::\n\n```{.r .cell-code}\n ## E(Ymax)\n\ngenerate_exp_max2 <- function(lambda, n) {\n  \n  single_sample2 <- rexp(n, lambda)\n  sample_max2 <- max(single_sample2)\n  \n  return(sample_max2)\n}\n\n## test function once:\ngenerate_exp_max2(lambda = lambda, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.455534\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3.915946\n\nnsim <- 5000      # number of simulations\n\nmaxs2 <- map_dbl(1:nsim, \\(i) generate_exp_max2(lambda = lambda, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmaxs_df2 <- tibble(maxs2)\nmaxs_df2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n   maxs2\n   <dbl>\n 1  3.68\n 2  1.42\n 3  3.60\n 4  5.43\n 5  5.30\n 6  4.68\n 7  2.56\n 8  3.13\n 9  2.14\n10  4.47\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmaxs_df2 |>\n  summarise(max_samp_dist = mean(maxs2),\n            var_samp_dist = var(maxs2),\n            sd_samp_dist = sd(maxs2))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  max_samp_dist var_samp_dist sd_samp_dist\n          <dbl>         <dbl>        <dbl>\n1          4.54          5.76         2.40\n```\n\n\n:::\n:::\n\n\n\n\n#Exponential Dist. Histograms\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mins_df2, aes(x = mins2)) +\n  geom_histogram(colour = \"darkolivegreen4\", fill = \"darkolivegreen1\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Mins\",\n       title = paste(\"Sampling Distribution of the \\nSample Mins when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df2, aes(x = maxs2)) +\n  geom_histogram(colour = \"purple\", fill = \"pink\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Maxs\",\n       title = paste(\"Sampling Distribution of the \\nSample Maxs when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-2.png){width=672}\n:::\n:::\n\n\n\n\n#Simulation for Y(min)~Beta(alpha = 8, beta = 2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5       # sample size\nalpha <- 8     \nbeta <- 2   \n\n# generate a random sample of n observations from a normal population\nsingle_sample3 <- rbeta(n, alpha, beta) |> round(2)\n# look at the sample\nsingle_sample3 \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.71 0.93 0.77 0.82 0.82\n```\n\n\n:::\n\n```{.r .cell-code}\n# compute the sample mean\nsample_min3 <- min(single_sample3)\n# look at the sample mean\nsample_min3  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.71\n```\n\n\n:::\n:::\n\n\n\n\n#Simulation for Y(max)~Beta(alpha = 8, beta = 2)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# compute the sample mean\nsample_max3 <- max(single_sample3)\n# look at the sample mean\nsample_max3  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.93\n```\n\n\n:::\n:::\n\n\n\n#Generating E(Ymin) & E(Ymax) for Beta Distribution\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngenerate_sample_min3 <- function(alpha, beta, n) {\n  \n  single_sample3 <- rbeta(n, alpha, beta)\n  sample_min3 <- min(single_sample3)\n  \n  return(sample_min3)\n}\n\n## test function once:\ngenerate_sample_min3(alpha = alpha, beta = beta, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5883812\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3.915946\n\nnsim <- 5000      # number of simulations\n\nmins3 <- map_dbl(1:nsim, \\(i) generate_sample_min3(alpha = alpha, beta = beta, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmins_df3 <- tibble(mins3)\nmins_df3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n   mins3\n   <dbl>\n 1 0.778\n 2 0.588\n 3 0.636\n 4 0.719\n 5 0.604\n 6 0.591\n 7 0.664\n 8 0.634\n 9 0.689\n10 0.601\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmins_df3 |>\n  summarise(mean_samp_dist = mean(mins3),\n            var_samp_dist = var(mins3),\n            sd_samp_dist = sd(mins3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1          0.648        0.0111        0.105\n```\n\n\n:::\n\n```{.r .cell-code}\n ## E(Ymax)\n\ngenerate_sample_max3 <- function(alpha, beta, n) {\n  \n  single_sample3 <- rbeta(n, alpha, beta)\n  sample_max3 <- max(single_sample3)\n  \n  return(sample_max3)\n}\n\n## test function once:\ngenerate_sample_max3(alpha = alpha, beta = beta, n = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.9220206\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 3.915946\n\nnsim <- 5000      # number of simulations\n\nmaxs3 <- map_dbl(1:nsim, \\(i) generate_sample_max3(alpha = alpha, beta = beta, n = n))\n\n## print some of the 5000 means\n## each number represents the sample mean from __one__ sample.\nmaxs_df3 <- tibble(maxs3)\nmaxs_df3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5,000 × 1\n   maxs3\n   <dbl>\n 1 0.901\n 2 0.959\n 3 0.871\n 4 0.986\n 5 0.960\n 6 0.979\n 7 0.910\n 8 0.911\n 9 0.929\n10 0.977\n# ℹ 4,990 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nmaxs_df3 |>\n  summarise(mean_samp_dist = mean(maxs3),\n            var_samp_dist = var(maxs3),\n            sd_samp_dist = sd(maxs3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 3\n  mean_samp_dist var_samp_dist sd_samp_dist\n           <dbl>         <dbl>        <dbl>\n1          0.922       0.00215       0.0464\n```\n\n\n:::\n:::\n\n\n\n\n#Beta Dist. Histograms\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = mins_df3, aes(x = mins3)) +\n  geom_histogram(colour = \"darkolivegreen4\", fill = \"darkolivegreen1\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Mins\",\n       title = paste(\"Sampling Distribution of the \\nSample Mins when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(data = maxs_df3, aes(x = maxs3)) +\n  geom_histogram(colour = \"purple\", fill = \"pink\", bins = 20) +\n  theme_minimal() +\n  labs(x = \"Observed Sample Maxs\",\n       title = paste(\"Sampling Distribution of the \\nSample Maxs when n =\", n))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n## create population graphs\n\nnorm_df <- tibble(x = seq(3, 17, length.out = 1000),\n                  dens = dnorm(x, mean = 10, sd = 2),\n                  pop = \"normal(10, 4)\")\nunif_df <- tibble(x = seq(7, 13, length.out = 1000),\n                  dens = dunif(x, 7, 13),\n                  pop = \"uniform(7, 13)\")\nexp_df <- tibble(x = seq(0, 10, length.out = 1000),\n                 dens = dexp(x, 0.5),\n                 pop = \"exp(0.5)\")\nbeta_df <- tibble(x = seq(0, 1, length.out = 1000),\n                  dens = dbeta(x, 8, 2),\n                  pop = \"beta(8, 2)\")\n\npop_plot <- bind_rows(norm_df, unif_df, exp_df, beta_df) |>\n  mutate(pop = fct_relevel(pop, c(\"normal(10, 4)\", \"uniform(7, 13)\",\n                                  \"exp(0.5)\", \"beta(8, 2)\")))\n\nggplot(data = pop_plot, aes(x = x, y = dens)) +\n  geom_line() +\n  theme_minimal() +\n  facet_wrap(~ pop, nrow = 1, scales = \"free\") +\n  geom_vline(  #geom_vline() to create vertical line for minimum\n    data = filter(pop_plot, pop == \"normal(10, 4)\"), #filter through pop_plot for normal dist ONLY\n    aes(xintercept = sample_min),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"uniform(7, 13)\"),\n    aes(xintercept = sample_min1),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"exp(0.5)\"),\n    aes(xintercept = sample_min2),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"beta(8, 2)\"),  #filter through pop_plot for beta dist ONLY\n    aes(xintercept = sample_min3),\n    color = \"red\"\n  ) +\n  labs(title = \"Population Distributions for Each Simulation Setting\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npop_plot <- bind_rows(norm_df, unif_df, exp_df, beta_df) |>\n  mutate(pop = fct_relevel(pop, c(\"normal(10, 4)\", \"uniform(7, 13)\",\n                                  \"exp(0.5)\", \"beta(8, 2)\")))\n\nggplot(data = pop_plot, aes(x = x, y = dens)) +\n  geom_line() +\n  theme_minimal() +\n  facet_wrap(~ pop, nrow = 1, scales = \"free\") +\n  geom_vline(  #geom_vline() to create vertical line for maximum now\n    data = filter(pop_plot, pop == \"normal(10, 4)\"), #filter through pop_plot for normal dist ONLY\n    aes(xintercept = sample_max),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"uniform(7, 13)\"),\n    aes(xintercept = sample_max1),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"exp(0.5)\"),\n    aes(xintercept = sample_max2),\n    color = \"red\"\n  ) +\n  geom_vline(\n    data = filter(pop_plot, pop == \"beta(8, 2)\"),  #filter through pop_plot for beta dist ONLY\n    aes(xintercept = sample_max3),\n    color = \"red\"\n  ) +\n  labs(title = \"Population Distributions for Each Simulation Setting\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n\n\n\n|  |  $\\text{N}(\\mu = 10, \\sigma^2 = 4)$  | $\\text{Unif}(\\theta_1 = 7, \\theta_2 = 13)$ | $\\text{Exp}(\\lambda = 0.5)$ | $\\text{Beta}(\\alpha = 8, \\beta = 2)$ |\n|:----:|:-----------------:|:-------------:|:------------:|:------------:|\n| $\\text{E}(Y_{min})$    |  7.669958     |   7.991146     |   0.4051406    |    0.6482102          |\n| $\\text{E}(Y_{max})$    |  12.33767     |    12.00729    |   4.538364    |     0.9214295         |\n|                        |       |        |        |              |\n| $\\text{SE}(Y_{min})$   |  1.333249     |   0.8342634     |  0.4029039\t    |  0.1051907            |\n| $\\text{SE}(Y_{max})$   |  1.337612     |  0.8492786      |  2.416008     |   0.04662133\t           |\n: Table of Results {.striped .hover}\n\n\n1. Briefly summarise how SE(Ymin) and SE(Ymax) compare for each of the above population models. Can you propose a general rule or result for how SE(Ymin) and SE(Ymax) compare for a given population?\n\nSE(Ymin) and SE(Ymax) in the Normal Distribution are the same and SE(Ymin) and SE(Ymax) for the Uniform Distribution are also the same. The standard errors are roughly symmetrical and this makes sense because the density plots of these two distributions for minimum and maximum behave symmetrical as well. For the Exponential and Beta Distributions, SE(Ymin) and SE(Ymax) are not the same or similar. It seems that in these distributions, because they are skewed both to the right and this causes more variability in standard error of the distributions. A general rule for how SE(Ymin) and SE(Ymax) compare for a given population might be if the population density is symmetrical, the Standard Errors of the maximum and minimum will be very close if not the same, and for skewed or asymmetrical population density, the maximum and minimum will have more variability causing the standard errors to most likely not match up. \n\n2. Choose either the third (Exponential) or fourth (Beta) population model from the table above. For that population model, find the pdf of Ymin⁡ and Ymax, and, for each of those random variables, sketch the pdfs and use integration to calculate the expected value and standard error. What do you notice about how your answers compare to the simulated answers? Some code is given below to help you plot the pdfs in R:\n\nThe answers I got from my hand calculations match up with the simulation calculations for E(Ymin) and E(Ymax) as well as the standard errors! \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\n## CHANGE 0 and 3 to represent where you want your graph to start and end\n## on the x-axis\nx <- seq(0, 3, length.out = 1000)\n## CHANGE to be the pdf you calculated. Note that, as of now, \n## this is not a proper density (it does not integrate to 1).\ndensity <- n * (-exp(-(0.5) * x))^4 * 0.5*exp(-0.5 *x)\n\n\n## put into tibble and plot\nsamp_min_df <- tibble(x, density)\nggplot(data = samp_min_df, aes(x = x, y = density)) +\n  geom_line() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- 5\n## CHANGE 0 and 3 to represent where you want your graph to start and end\n## on the x-axis\nx1 <- seq(0, 3, length.out = 1000)\n## CHANGE to be the pdf you calculated. Note that, as of now, \n## this is not a proper density (it does not integrate to 1).\ndensity1 <- n * (1-exp(-0.5 * x1))^4 * 0.5*exp(-0.5 *x1)\n\n\n## put into tibble and plot\nsamp_max_df <- tibble(x, density1)\nggplot(data = samp_max_df, aes(x = x, y = density1)) +\n  geom_line() +\n  theme_minimal()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}